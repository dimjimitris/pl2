Require Import Coq.Init.Nat Coq.Arith.Arith Coq.Lists.List.
Import ListNotations. 

(** Στοιχεία Σπουδαστή
Όνομα:  
ΑΜ: 
*)


(** * Εργασία 2 (100 μονάδες + 10 μονάδες bonus) *)

(** Ο σκοπός αυτής της εργασίας είναι να εξοικειωθείτε με συναρτησιακό
    προγραμματισμό και την ανάπτυξη αποδείξεων στο Coq Proof Assistant.

    Οδηγίες:

    - Μπορείτε να χρησιμοποιείτε μόνο τα tactics που έχουμε κάνει στο μάθημα.  

    - Δεν μπορείτε να χρησιμοποιήσετε θεωρήματα απο την βιβλιοθήκη, εκτός και αν
      αυτό υποδεικνύεται από την άσκηση.

    - Εάν κολλήσετε σε κάποιο ενδιάμεσο lemma ή proof goal, μπορείτε να
      χρησιμοποιήσετε [admit] ώστε ολοκληρώσετε την άσκηση και να βαθμολογηθείτε
      για ότι έχετε λύσει.
    
    - To παραδοτέο αρχείο θα πρέπει να κάνει compile. Αυτό μπορείτε να το ελέγεξετε 
      στο terminal σας με την εντολή `coqc hw.1`. Τα αρχεία που δεν κάνουν compile 
      δεν θα βαθμολογούνται.

    - Όταν ολοκληρώνετε κάποια απόδειξη, αντικαταστήστε το τελικό [Admitted] με
      [Qed].

    - Μην αλλάζετε τον κώδικα και το κείμενο που σας έχουν δωθεί. Μην γράφετε
      μέσα στα στα σχόλια της βαθμολόγησης. Αυτό είναι απαραίτητο για την ομαλή
      και έγκαιρη βαθμολόγηση των εργασιών. Μπορείτε να γράψετε όπου υπάρχει η
      οδηγία (*  ___ FILL IN HERE ___ *). Εάν σας εξυπηρετεί, μπορείτε
      να ορίζετε βοηθητικές συναρτήσεις, λήμματα, ορισμούς, κ.α.
      
    - Συμπληρώστε σωστά τα στοιχεία σας στην αρχή του αρχείου. Αυτό είναι 
      απαραίτητο για την σωστή βαθμολόγηση των εργασιών. *)


(** ** Άσκηση 1: Σύνθεση Συναρτήσεων (5 μονάδες) *)

(** Συμπληρώστε τον ορισμό μιας συνάρτησης που παίρνει ως ορίσματα δύο
    συναρτήσεις και επιστρέφει τη σύνθεσή τους. *)

Definition comp {A B C : Type} (f : A -> B) (g : B -> C) : A -> C (* :=   ___ FILL IN HERE ___. *)
. Admitted. (* Διαγράψτε αυτή τη γραμμή και συμπληρώστε την από πάνω *)

(* [comp] Grade: 0/1 *)


(** Συμπληρώστε τον ορισμό του κατηγορήματος (predicate) που δηλώνει
    ότι μια συνάρτηση να είναι ένα-προς-ένα (injective). *)

Definition injective {A B : Type} (f : A -> B) : Prop (* :=   ___ FILL IN HERE ___. *)
. Admitted. (* Διαγράψτε αυτή τη γραμμή και συμπληρώστε την από πάνω *)

(* [injective] Grade: 0/1 *)

(** Αποδείξτε ότι η σύνθεση συναρτήσεων που είναι ένα-προς-ένα, είναι
    και αυτή μια ένα-προς-ένα συνάρτηση.

    Αντικαταστήστε το [False] με τη σωστή διατύπωση. *)

Theorem comp_injective :
  forall A B C (f : A -> B) (g : B -> C), False. (* ___ FILL IN HERE ___ *)
Proof. 
(*  ___ FILL IN HERE ___ *)
Admitted.

(* [comp_injective] Grade: 0/3 *)


(** ** Άσκηση 2: Φυσικοί αριθμοί στο δυαδικό σύστημα (30 μονάδες) *)

(** Σας δίνεται ένας επαγωγικός τύπος που αναπαριστά φυσικούς αριθμούς
    στο δυαδικό σύστημα καθώς και οι ορισμοί [bin_to_nat], [bin_incr]
    και [nat_to_bin] από την προηγούμενη άσκηση. *)

Inductive bin : Type :=
| Z : bin
| B0 : bin -> bin
| B1 : bin -> bin.

Fixpoint bin_to_nat (b : bin) : nat :=
  match b with
  | Z => 0
  | B0 x => 2 * bin_to_nat x
  | B1 x => 1 + 2 * bin_to_nat x
  end.

Fixpoint bin_incr (b : bin) : bin :=
  match b with
  | Z => B1 Z
  | B0 x => B1 x
  | B1 x => B0 (bin_incr x)
  end.

Fixpoint nat_to_bin (n : nat) : bin :=
  match n with
  | O => Z
  | S x => bin_incr (nat_to_bin x)
  end.


(** Αποδείξτε ότι, για κάθε δυαδικό αριθμό, η αύξηση του κατά ένα και
    στη συνέχεια η μετατροπή του σε μοναδιαίο φυσικό αριθμό, δίνει το
    ίδιο αποτέλεσμα με τη μετατροπή του σε μοναδιαίο αριθμό και στη
    συνέχεια την αύξηση αυτού του μοναδιαίου αριθμού κατά ένα. *)

(** Μπορείτε να χρησιμοποιήσετε τα θεωρήματα βιβλιοθήκης [plus_n_O]
    και [plus_n_Sm]. Καθώς το συμπέρασμα των θεωρημάτων αυτών είναι
    μία ισότητα, μπορείτε να τα χρησιμοποιήσετε με το tactic [rewrite].
    
    Π.χ. [rewrite plus_n_O] ή [rewrite <- plus_n_O] *)

Check plus_n_O.
Check plus_n_Sm.

Lemma bin_to_nat_pres_incr :
  forall b : bin, bin_to_nat (bin_incr b) = 1 + (bin_to_nat b).
Proof.
(*  ___ FILL IN HERE ___ *)
Admitted.

(* [bin_to_nat_pres_incr] Grade: 0/20 *)

(** Χρησιμοποιώντας το παραπάνω λήμμα, αποδείξτε ότι για κάθε δυαδικό
    αριθμό, η μετατροπή του σε μοναδιαίο αριθμό και στη συνέχεια η
    μετατροπή του αποτελέσματος ξανά σε δυαδικό επιστρέφει τον αρχικό
    αριθμό. Δηλαδή, ότι η σύνθεση των συναρτήσεων [bin_to_nat] και
    [nat_to_bin] είναι η ταυτοτική συνάρτηση. *)

Theorem nat_bin_nat :
  forall n, bin_to_nat (nat_to_bin n) = n.
Proof.
(*  ___ FILL IN HERE ___ *)
Admitted.

(* [nat_bin_nat] Grade: 0/10 *)



(** ** Άσκηση 3: Λογική (20 μονάδες) *)

(** Όπως αναφέραμε στο μάθημα, o νόμος της εξάλειψης της διπλής
    άρνησης (double negation elimination) είναι ισοδύναμος με το νόμο
    του αποκλειόμενου μέσου (excluded middle). Η άσκηση αυτή σας
    ζητάει να αποδείξετε και τυπικά αυτό το ισχυρισμό και σας
    καθοδηγεί ώστε να αποδείξετε τα απαραίτητα ενδιάμεσα λήμματα. *)

(** Θα χρειαστεί να αποδείξουμε τον νόμο του De Morgan για την άρνηση
    μιας λογικής διάζευξης.

    Παρατηρήστε ότι το tactic [auto] βρίσκει κατευθείαν την
    απόδειξη. Η άσκηση σας ζητά να μην χρησιμοποιήσετε [auto] αλλά να
    βρείτε την απόδειξη με χρησιμοποιόντας τα tactics [intros],
    [apply], [split], [left], [right], [assumption]. *)

Lemma de_morgan_or :
  forall (A B : Prop), ~ (A \/ B) -> ~ A /\ ~ B. 
Proof.
(*  ___ FILL IN HERE ___ *)
Admitted.

(* [de_morgan_or] Grade: 0/3 *)

(** Χρησιμοποιώντας το παραπάνω λήμμα, δείξτε ότι ισχύει η διπλή άρνηση του
    απολυόμενου μέσου. *)

Lemma not_not_EM : forall P, ~~ (P \/ ~ P).
Proof.
(*  ___ FILL IN HERE ___ *)
Admitted.

(* [not_not_EM] Grade: 0/3 *)


(** Για ευκολία, ορίζουμε τις δύο λογικές προτάσεις ώστε να μπορούμε 
    να αναφερόμαστε σε αυτές με ονόματα. *)

Definition DNE : Prop := forall P, ~~ P -> P. 

Definition EM : Prop := forall P, P \/ ~P. 


(** Μπορούμε τώρα να αποδείξουμε τον ισχυρισμό ότι οι δύο λογικές
    προτάσεις είναι ισοδύναμες. Για κάθε μια απο τις δύο κατευθύνσεις
    θα πρέπει να χρησιμοποιήσετε την υπόθεση κάνοντας την instantiate
    με την κατάλληλη λογική πρόταση στη θέση του καθολικά
    ποσοτικοποιημένου [P]. Αυτή η πρόταση θα είναι διαφορετική σε κάθε
    μία από τις δύο περιπτώσεις.

    Hint: Αυτό μπορείτε να το κάνετε είτε με το tactic [specialize H with (n := p)]
    είτε με το tactic [apply H with (P := p)] (χρησιμοποιόντας τα κατάλληλα
    [H], [P] και [p]) όπως είδαμε στο logic.v *)

Theorem DNE_EM : DNE <-> EM.
Proof.
  unfold DNE, EM.
  
  (* Θυμηθείτε ότι η ισοδυναμία ορίζεται ως σύζευξη δύο
     συνεπαγωγών. Μπορούμε λοιπόν να χρησιμοποιήσουμε το tactic
     [split] ώστε να δουλέψουμε ξεχωριστά με κάθε συνεπαγωγή. *) 
  split.
  
  - (* DNE -> EM *)
    admit. (*  ___ FILL IN HERE ___ *)
    (* Hint: χρησιμοποιήστε το λήμμα [not_not_EM]. *)
    
  - (* EM -> DNE *)
    admit. (*  ___ FILL IN HERE ___ *)
Admitted.

(* [DNE_EM] Grade: 0/5 *)


(** Προσπαθήστε να δείξετε το νόμο του De Morgan για τη λογική
    σύζευξη. Τι παρατηρείτε; Γιατί συμβαίνει αυτό; *)

Lemma de_morgan_and :
  forall (A B : Prop), ~ (A /\ B) -> ~ A \/ ~ B. 
Proof.
Abort.

(** Σύντομη απάντηση: ___ FILL IN HERE ___ *)

(* [de_morgan_and] Grade: 0/4 *)

(** Αποδείξτε τώρα το ίδιο λήμμα, υποθέτοντας τον νόμο του αποκλειόμενου μέσου. *)

Lemma de_morgan_and_ΕΜ :
  EM ->
  forall (A B : Prop), ~ (A /\ B) -> ~ A \/ ~ B.
Proof.
(*  ___ FILL IN HERE ___ *)
Admitted.

(* [de_morgan_and_ΕΜ] Grade: 0/5 *)



(** ** Άσκηση 4: Λίστες (50 μονάδες) *)

(** Γράψτε μία επαγωγική σχέση (inductive relation), που να ισχύει όταν 
    ένα στοιχείο τύπου [Α] ανοίκει σε μία λίστα τύπου [list A].
*)

Inductive In {A : Type} (x : A) : list A -> Prop := 
(*  ___ FILL IN HERE ___ *)
.

(* [In] Grade: 0/2 *)


(** Αποδείξτε ότι για κάθε συνάρτηση (f : A -> B) εάν ένα στοιχείο (x : A)
    ανοίκει σε μία λίστα [l], τότε το στοιχείο [f x] θα ανοίκει στην λίστα [map f l]. *)

Lemma In_map : 
 forall (A B : Type) (x : A) (l : list A) (f : A -> B),  
    In x l -> In (f x) (map f l). 
Proof. 
(*  ___ FILL IN HERE ___ *)
Admitted.

(* [In_map] Grade: 0/2 *)


(** Γράψτε μία συνάρτηση [fold_left] πολυμορφική στους τύπους [Α] και
    [Β], που παίρνει ως όρισμα μία συνάρτηση [f : A -> B -> A], μια
    λίστα [l : list B] και μια αρχική τιμή [a0 : A].

    Εάν η λίστα είναι ή [[x1; x2 ...; xn]] τότε το αποτέλεσμα της
    συνάρτησης είναι το [f (... (f (f a0 x1) x2)...) xn]. Η συνάρτηση
    επιστρέφει το [a0] εάν η λίστα είναι η κενή.

    Δηλαδή, η συνάρτηση εφαρμόζει διαδοχικά την [f] σε κάθε στοιχείο
    της λίστας, ξεκινώντας από το πρώτο (αριστερό) στοιχείο και
    χρησιμοποιώντας ως πρώτο όρισμα το [a0]. Το αποτέλεσμα της
    εφαρμογής της [f] σε ένα στοιχείο χρησιμοποιείται ως πρώτο όρισμα
    στην επόμενη εφαρμογή της [f] στο επόμενο στοιχείο της λίστας. *)

(** Σημείωση: To annotation [{struct l}] λέει στο Coq ποίο είναι το
    αναδρόμικό όρισμα μιας συνάρτησης. Σε αυτή την περίπτωση είναι
    απαραίτητο για τεχνικούς λόγους ώστε το Coq να αποδεχτεί τον
    [Αdmitted] ορισμό χωρίς το σώμα της συνάρτησης. *)


Fixpoint fold_left {A B} (f : A -> B -> A) (l : list B) (a0 : A) {struct l} : A 
(* :=   ___ FILL IN HERE ___. *)
. Admitted. (* Διαγράψτε αυτή τη γραμμή και συμπληρώστε την από πάνω *)

(* [fold_left] Grade: 0/2 *)

(** Προθέρμανση: χρησιμοποιήστε την [fold_left] για να γράψετε μία συνάρτηση [length] *)

Definition length (l : list nat) : nat (* :=   ___ FILL IN HERE ___. *)
. Admitted. (* Διαγράψτε αυτή τη γραμμή και συμπληρώστε την από πάνω *)

(* [length] Grade: 0/0.5 *)

Example test_length : length [1;2;3;4] = 4. 
Admitted. (* Για να ελέγξετε τον ορισμό σας, διαγράψτε αυτή τη γραμμή και κάντε uncomment την από κάτω. *)
(* Proof. reflexivity. Qed. *)

(** Προθέρμανση: χρησιμοποιήστε την [fold_left] για να γράψετε μία συνάρτηση που
    αθροίζει τα στοιχεία μιας λίστας φυσικών αριθμών *)
Definition sum (l : list nat) : nat (* :=   ___ FILL IN HERE ___. *)
. Admitted. (* Διαγράψτε αυτή τη γραμμή και συμπληρώστε την από πάνω *)

(* [sum] Grade: 0/0.5 *)

Example test_sum : sum [1;2;3;4] = 10. 
Admitted. (* Για να ελέγξετε τον ορισμό σας, διαγράψτε αυτή τη γραμμή και κάντε uncomment την από κάτω. *)
(* Proof. reflexivity. Qed. *)



(** Αποδείξτε ότι αν μια συνάρτηση [f : A -> A -> A] είναι αντιμεταθετική και
    προσεταιριστική τότε για κάθε λίστα [l], αρχική τιμή [a0] και τιμή [a], ισχύει:

              [f (fold_left f l a0) a = fold_left f l (f a0 a)] 

    Για να αποδείξετε αυτό τον ισχυρισμό είναι πολύ σημαντικό να έχετε μια
    επαρκώς γενική επαγωγική υπόθεση. Θυμηθείτε ότι μπορείτε να γενικεύετε
    μεταβλητές που βρίσκονται στο proof context με το tactic [revert].

    Αντικαταστήστε το [False] με τη σωστή διατύπωση.
*)

Theorem fold_left_assoc_comm :
  False (* ___ FILL IN HERE ___ *). 
Proof. 
(*  ___ FILL IN HERE ___ *)
Admitted.

(* [fold_left_assoc_comm] Grade: 0/25 *)


(** Γράψτε μία συνάρτηση fold_right πολυμορφική στους τύπους Α και Β,
    που παίρνει ως όρισμα μία συνάρτηση [f : B -> A -> A], μια λίστα
    [l] και μια αρχική τιμή [a0].

    Εάν η λίστα είναι ή [[x1; ...; xn]] τότε το αποτέλεσμα της
    συνάρτησης είναι το [f x1 (f x2 (... (f xn a0))))]. Η συνάρτηση
    επιστρέφει το [a0] εάν η λίστα είναι η κενή.

    Δηλαδή, η συνάρτηση εφαρμόζει διαδοχικά την [f] σε όλα τα στοιχεία
    της λίστας, ξεκινώντας από το τελευταίο (δεξιό) στοιχείο,
    χρησιμοποιώντας ως δεύτερο όρισμα το [a0]. Το αποτέλεσμα της
    εφαρμογής της [f] σε ένα στοιχείο χρησιμοποιείται ως δεύτερο
    όρισμα στην επόμενη εφαρμογή της [f] στο προηγούμενο στοιχείο
    της λίστας. *)

Fixpoint fold_right {A B} (f : B -> A -> A) (l : list B) (a0 : A) {struct l} : A  
(* :=   ___ FILL IN HERE ___. *)
. Admitted. (* Διαγράψτε αυτή τη γραμμή και συμπληρώστε την από πάνω *)

(* [fold_right] Grade: 0/2 *)

(** Προθέρμανση: χρησιμοποιήστε την [fold_right] για να γράψετε μία συνάρτηση [length'] *)

Definition length' (l : list nat) : nat (* :=   ___ FILL IN HERE ___. *)
. Admitted. (* Διαγράψτε αυτή τη γραμμή και συμπληρώστε την από πάνω *)

(* [length'] Grade: 0/0.5 *)

Example test_length' : length' [1;2;3;4] = 4.
Admitted. (* Για να ελέγξετε τον ορισμό σας, διαγράψτε αυτή τη γραμμή και κάντε uncomment την από κάτω. *)
(* Proof. reflexivity. Qed. *)

(** Προθέρμανση: χρησιμοποιήστε την [fold_right] για να γράψετε μία
    συνάρτηση που αθροίζει τα στοιχεία μιας λίστας φυσικών αριθμών *)

Definition sum' (l : list nat) : nat (* :=   ___ FILL IN HERE ___. *)
. Admitted. (* Διαγράψτε αυτή τη γραμμή και συμπληρώστε την από πάνω *)

(* [sum'] Grade: 0/0.5 *)

Example test_sum' : sum' [1;2;3;4] = 10. 
Admitted. (* Για να ελέγξετε τον ορισμό σας, διαγράψτε αυτή τη γραμμή και κάντε uncomment την από κάτω. *)
(* Proof. reflexivity. Qed. *)

(** Αποδείξτε ότι αν μια συνάρτηση [f : A -> A -> A] είναι
    αντιμεταθετική και προσεταιριστική τότε για κάθε λίστα [l] και αρχική
    τιμή [a0], ισχύει:

                  [fold_right f l a0 = fold_left f l a0]

    Αντικαταστήστε το [False] με τη σωστή διατύπωση. *)

(** Σημείωση: Για να αποδείξετε το παρακάτω θεώρημα θα χρειαστεί να
    χρησιμοποιήσετε το λήμμα [fold_left_assoc_comm]. Καθώς το
    συμπέρασμα του λήμματος είναι μια ισότητα μπορείτε να το
    χρησιμοποιήσετε με το [rewrite] tactic. Όταν το κάνετε αυτό το Coq
    θα σας ζητήσει να αποδείξετε όλες τις προϋποθέσεις (premises) του
    λήμματος. *)

Theorem fold_left_fold_right :
  False (* ___ FILL IN HERE ___*).
Proof. 
(*  ___ FILL IN HERE ___ *)
Admitted.

(* [fold_left_fold_right] Grade: 0/10 *)


(** Γράψτε μία συνάρτηση [foo : A -> A -> A] για κάποιο τύπο [Α] της
    επιλογής σας για τον οποίο οι συναρτήσεις [fold_left] και
    [fold_right] επιστρέφουν διαφορετικά αποτελέσματα όταν
    εφαρμόζονται στην ίδια λίστα και στην ίδια αρχική τιμή. Τι
    χαρακτηριστικά έχει αυτή η συνάρτηση; Γράψτε δύο παραδείγματα, στο
    πρότυπο των [test_sum] και [test_sum'] που να δείχνουν ότι η
    συνάρτηση επιστρέφει διαφορετικό αποτέλεσμα. *)

(*  ___ FILL IN HERE ___ *)

(* [fold_left_fold_right_different] Grade: 0/5 *)
